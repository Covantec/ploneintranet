<html xmlns="http://www.w3.org/1999/xhtml"
      xml:lang="en"
      xmlns:tal="http://xml.zope.org/namespaces/tal"
      xmlns:metal="http://xml.zope.org/namespaces/metal"
      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
      lang="en"
      metal:use-macro="context/search_template/macros/search"
      i18n:domain="ploneintranet">
  <metal:results fill-slot="results">
  <div class="container results">
    <div class="row"
         tal:define="
            search_response view/search_response;
            display_previews view/show_previews;
            results_sorting python:view.request.get('results-sorting', 'relevancy');
          ">
      <div class="three columns filters">
        <fieldset class="pat-subform pat-autosubmit pat-inject"
                  data-pat-inject="source: #listing; target: #listing;"
                  tal:condition="search_response">
          <!-- The hidden input below always gets the same value as the
               searchbox it self in each result. This is needed to make sure
               when the filters are changed within their subform, they are posted to the server
               also together with the search term. -->
          <input type="hidden"
                 name="SearchableText_filtered"
                 value="${request/SearchableText|request/SearchableText_filtered|nothing}" />
          <!-- The pat-depends condition below should be composed dynamically
               based on the document types and tags listed on the page.
               Alternately, all possible document types and tags that are used system wide
               could be populated here, but that might generate a really long list. -->
          <p class="button-bar pat-depends"
                  tal:condition="view/reset_filters_pat_condition"
                  data-pat-depends="condition: friendly_type_name or tags; transition: slide">

            <a class="pat-button icon-cancel-circle pat-inject"
               href="${request/getURL}?SearchableText=${request/SearchableText|request/SearchableText_filtered|nothing}"
               data-pat-inject="source: #results; target: #results"
               i18n:translate=""
               >Reset filters</a>
          </p>
          <fieldset class="pat-checklist pat-bar-toggles document-types"
                    tal:condition="view/type_facets">
            <legend>Document types</legend>
            <!-- Only list content types in this list that are relevant for this search result. -->
            <tal:for repeat="type view/type_facets">
              <label class="${type/id}">
              <input name="friendly_type_name"
                     checked="${python:type['id'] in request and 'checked' or None}"
                     type="checkbox"
                     value="${type/title}"
                      />${type/title}
              <!--sup class="counter">${type/counter}</sup--></label>
            </tal:for>
          </fieldset>
          <fieldset class="vertical">
            <legend>Date range</legend>
            <label>
              <input type="date"
                     name="start_date"
                     class="pat-date-picker"
                     placeholder="Created after&hellip;"
                     value="${python:request.get('created_after')}"
                     i18n:attributes="placeholder label_created_after;" />
            </label>
            <label>
              <input type="date"
                     name="end_date"
                     class="pat-date-picker"
                     placeholder="Created before&hellip;"
                     value="${request/created_before|nothing}"
                     i18n:attributes="placeholder label_created_before;" />
            </label>
          </fieldset>
          <fieldset class="pat-checklist pat-bar-toggles tags"
                    tal:condition="view/tag_facets">
            <legend>Tags</legend>
            <!-- Only list tags in this list that are relevant for this search
                 result. Tags are ordered by occurance count. Should there be no
                 objects tags in the search results, then this entire fieldset is not printed.
                 The total amount of checkboxes is maximised to 8. Should there be more different
                 tags in the search result, then those are bundled under 'All other tags' as a
                 9th item. -->
            <tal:for repeat="tag view/tag_facets">
              <label>
              <input type="checkbox"
                     checked="${python:tag['id'] in request and 'checked' or None}"
                     name="tags"
                     value="${tag/title}"
              />${tag/title}</label>
            </tal:for>
          </fieldset>
        </fieldset>
      </div>
      <div class="nine columns last document-listing"
           id="listing">
        <p class="introduction">
          <tal:if condition="search_response/total_results|nothing">

            <span tal:replace="search_response/total_results">
            87</span>
            <span i18n:translate=""
                  tal:omit-tag="">items matched your search.</span>
          </tal:if>
        </p>
        <p class="did-you-mean"
           tal:define="corrected search_response/spell_corrected_search|nothing"
           tal:condition="corrected">
        <span i18n:translate=""
              tal:omit-tag="">Did you mean</span>
        <strong>
          <a href="${here/portal_url}/@@search?SearchableText=${corrected}"
             tal:content="corrected"></a>
        </strong>?</p>
        <!-- The class 'previews-on' may be changed out with 'previews-off' depending on
             the state of the checkbox 'display-previews' that appears in the options tooltip.
             The class is set server side (the search results reload)
             and should be stored in the user profile as a preference. -->
        <dl class="search-results previews-${python: display_previews and 'on' or 'off'}"
            id="result-listing"
            data-search-string="${request/QUERY_STRING|nothing}">
          <!-- One hard coded example of an archived workspace as a search result: -->
          <tal:result repeat="result search_response">
            <dt class="title type-${result/portal_type}">
              <a href="${result/url}${python:view.url_fragments.get(result.portal_type)}">
                ${result/title}
                <!--strong class="icon-${result/review_state} workspace-state ${result/review_state}">${result/review_state}</strong-->
              </a>
            </dt>
            <dd class="description type-${result/portal_type}">
              <tal:preview tal:define="preview_class python: view.preview_class(result.portal_type);">

                <a href="${result/url}${python:view.url_fragments.get(result.portal_type)}"
                   class="preview ${preview_class}">
                  <img src="${result/preview_image_url}"
                       class="${python: preview_class == 'user' and 'pat-avatar' or ''}"
                       alt=""
                       tal:condition="result/preview_image_url" />
                  <img src="++theme++ploneintranet.theme/generated/media/logo-pi.svg"
                       tal:condition="not: result/preview_image_url" />
                  <h4 class="name"
                      tal:content="result/title"
                      tal:condition="python: preview_class == 'user'" />
                </a>
              </tal:preview>
              <tal:highlights condition="result/highlighted_summary">

                <p class="fragment"
                   tal:content="structure result/highlighted_summary">
                   </p>
              </tal:highlights>
              <tal:nohighlights condition="not: result/highlighted_summary">

                <p class="fragment"
                   tal:condition="result/description"
                   tal:content="result/description"></p>
              </tal:nohighlights>
              <a href="${result/url}${python:view.url_fragments.get(result.portal_type)}"
                 class="link"
                 tal:content="python:view.friendly_path(result.url)">
                 {{ result.url }}</a>
            </dd>
          </tal:result>
          <tal:autoload define="next_url python: search_response and view.next_page_url(search_response.total_results)">

            <dd id="load-more-results"
                tal:condition="next_url">
              <!-- The link below is what would basically be the 'Next' link
                   when you have pagination. Batches of 10 results or so would
                   be nice. -->
              <!-- This is an example for infinate scrolling with a list (DL or
                   UL or OL), which is a little bit different from non list
                   cases. In non list cases, the link tag is replaced by the injection, but a link
                   tag may not be placed directly into a list tag. Therefor the DD is replaced
                   instead. In case of OL/UL an extra LI tag is added. -->
              <a href="${request/getURL}#result-listing"
                 class="pat-inject infinite-scrolling-trigger"
                 data-pat-inject="trigger: autoload-visible; source: #result-listing; target: #load-more-results::element"
                 i18n:translate="">Loading more search
                 results&hellip;</a>
            </dd>
          </tal:autoload>
        </dl>
      </div>
    </div>
  </div>
  </metal:results>
</html>
